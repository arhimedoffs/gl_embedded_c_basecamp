# Перечень замечаний и ответов по ним

## 2-e

_Замечание_ По второму заданию вижу, что заводим МК в режим сна? Это гуд! :slightly_smiling_face:
Только зачем перекрывать функцию HAL_Delay?
Можно просто свою сделать же... HAL_DelaySleep.

_Ответ_ Ну они сами в библиотеке указали `HAL_Delay` как `__weak`. Плюс такой подход позволяет
повлиять на задержки во всех системных функциях библиотеки и стороннем совместимом с HAL коде
(что конечно требует проверки)

## 3-е

_Замечания_

1. Для каналов логично enum ввести.
2. timChannel = (timChannel + 1) % 4; Красиво выглядит, а если я запрошу 3 канала или 5-ть?
3. Функцию updatePWM лучше сделать с параметрами. Все что нужно для функции - передать в качестве
параметров.
4. Есть ли смысл держать столько глобальных переменных или можно их спрятать в локальные функции
в main например. Меньше область видимости - меньше вероятность что их изменят снаружи непреднамеренно.
По п. 4 нашел - в прерываниях пользуется. Глобальные ОК.
5. divRound - точно этой функции нет в стандартной либе?
6. Magic Number "100". Ctrl+C+V trouble.
`timPWM = (timPWMNew > 100) ? 100 : (uint8_t)timPWMNew`
`#define it`

_Ответы_

1. Добавлено
2. Исправлено
3. Исправлено
4. -
5. Не нашел
6. Исправлено

## 4-е

_Замечания_

1. Все значения под #define скобки во избежание непонятных эффектов.
`#define LED_CCR_BLUE htim4.Instance->CCR4`
2. К функциям нужны блоки комментариев. Чтобы было понятно что и зачем происходит, какие параметры,
возвращаемое значение. И т.д...
3. warningBlink явно должна быть с параметрами.
4. Функция main нуждается в рефакторинге. Разбить на ряд более мелких функций (с параметрами!).
5. Оформить как калибровочные функции (или макросы) с говорящими именами.
`extTemperature = -chVoltages[1] / 20 + 1010;`
`intTemperature = (chVoltages[2] - 7600) * 10 / 25 + 250;`
6. Читать Макконнел С. Code complete `https://drive.google.com/file/d/1iaFOKHIxCrAXXNSSgs-E33BCap61UsuH/view`
II.7 Высококачественные методы. Книга заслуживает внимания.

_Ответы_

1. Исправлено
2. Дописано
3. Исправлено
4. Частично
5. Исправлено
6. Почитаем

## 5-е

_Замечания_

main нужно разбить на несколько подфункций.
Функция должна быть полноценной. Все что надо для ее работы - передается через параметры.
На выходе - результат. В идеале - мы можем скопировать ее в новый проект (тело) и она будет работать.
Слишком большая зависимость от глобальных переменных.

_Ответы_

Выполнено частично

Конечно теоретически я только за. И мне весьма импонирует подход Lisp. Но как быть к примеру с кодом обработки кнопок.
Если делать универсально, то нужно создать модуль аналогичный FreeRTOS+CLI, со своим уровнем абстракции.
Я счел что это выходит за рамки данной лабораторной. А делать функцию, которая будет обрабатывать коды кнопок и выдавать
команды через результирующую переменную можно. Только копирование её в другой проект будет лишено какого либо смысла,
т.к. самое тело сильно привязано к конкретной задаче.
Наглядным примером выглядят функции генерируемые CubeIDE в файле `main.c`. Они не имеют никаких параметров,
ничего не возвращают, вынесены исключительно для читаемости, и не подразумевают копирование в другие проекты.
Аналогично выглядит и реализация функционала через callback функции в HAL. Они также не могут быть написаны без
использования глобальных переменных.

## 6-е

_Замечания_

Нарушены слои абстракции.
main function layer
---------- uses --------
pca9685lib
---------- uses --------
i2c driver
---------- uses --------
pca device

Либе нужны i2c handle и OE pin. Предоставь их в рамках инициализации либы.
Вся внутрянка относящаяся к работе чипа - прячется внутрь либы.
Вся работа по командам идущим по i2c спрячется внутрь либы, так же как и обработка OE линии.
Внаружу либа покажет функции для доступа к PWM каналам и прочие интерфесные функции.
Их вынести в хедер вместе с паблик типами (все остальное внутрь - private).
Каналы оформить как enum список (16 каналов + вариант для всех сразу).
Функции...
Initialize(config)
SetChannelMode(channel, mode)
mode - enum on/off
SetChannelDutyCycle(channel, parameters)
OutputEnableControl(mode) - для контроля ОЕ линии.

_Ответ_

В таком плане у меня возникает вопрос касательно абстрагирования, если мы по такой схеме завяжем либу работы с
драйвером ШИМ к конкретно этой однокристалке. А как быть, если мы захотим работать с этим же драйвером из Arduino (к примеру).
Также это исключит возможность использовать bit-bang обмен для I2C (допустим ножки порта заняты).
Поэтому и была выбрана схема, когда пользователь реализует 2 callback функции для работы с I2C и управления разрешения драйвера.
При этом код без изменений может быть перенесен на другую апаратную платформу.
